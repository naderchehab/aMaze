<html>

<head>
<title>aMaze</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>

<script type="text/javascript">
"use strict";
    var gl;
	var ANIM_SPEED = 15;
	var CELL_SIZE = 22;
	var GRID_WIDTH = 30;
	var COLOR= "#4380D3";
	var BG_COLOR= "#000000";
	
    function initGL(canvas) {
        try {
            gl = canvas.getContext("2d");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
			gl.lineWidth="2";
			gl.strokeStyle = COLOR;
			gl.moveTo(0,0);		
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }
	
	// create a grid in memory
	function createGrid() {
			var grid = [];
			
			for (var i = 0; i < GRID_WIDTH; i++) {
				grid[i] = [];
				
				for (var j = 0; j < GRID_WIDTH; j++) {
					var walls = 15;
					var cell = createCell(j, i, walls);
					grid[i].push(cell);
				}
			}
			
			return grid;
		}
		
	// Generate maze using the recursive backtracking algorithm
	function generateMaze(grid) {
		
		var visitedCells = [];
		
		var locHistory = []; // used to animate the generation of the grid
		
		// pick a random cell
		var x = Math.floor((Math.random()*GRID_WIDTH));
		var y = Math.floor((Math.random()*GRID_WIDTH));
				
		grid[y][x].visited = true;
		visitedCells.push(grid[y][x]);
		
		while (visitedCells.length < GRID_WIDTH*GRID_WIDTH) {
					
			locHistory.push({x: x, y: y});
					
			// find unvisited neighbouring cells
			
			var unvisitedNeighbours = [];
			
			if (y-1 >= 0 && grid[y-1][x].visited == false) {
				unvisitedNeighbours.push("N");
			}	
			
			if (y+1 <= GRID_WIDTH-1 && grid[y+1][x].visited == false) {
				unvisitedNeighbours.push("S");
			}
			
			if (x-1 >= 0 && grid[y][x-1].visited == false) {
				unvisitedNeighbours.push("W");
			}
			
			if (x+1 <= GRID_WIDTH-1 && grid[y][x+1].visited == false) {
				unvisitedNeighbours.push("E");
			}
						
			// if there are unvisited neighbouring cells
			if (unvisitedNeighbours.length > 0) {		
				// among the unvisited neighbouring cells, pick a random one
				// and destroy the wall between the current cell and that neighbouring one.
				// Make the new cell the current one.
				
				var randomIndex = Math.floor(Math.random()*unvisitedNeighbours.length);
				
				switch (unvisitedNeighbours[randomIndex]) {
					case "N":
					destroyWall(grid, x, y, "N");
					grid[y-1][x].visited = true;
					visitedCells.push(grid[y-1][x]);
					y--;
					break;
					case "S":
					destroyWall(grid, x, y, "S");
					grid[y+1][x].visited = true;
					visitedCells.push(grid[y+1][x]);
					y++;
					break;
					case "W":
					destroyWall(grid, x, y, "W");
					grid[y][x-1].visited = true;
					visitedCells.push(grid[y][x-1]);
					x--;
					break;
					case "E":
					destroyWall(grid, x, y, "E");
					grid[y][x+1].visited = true;
					visitedCells.push(grid[y][x+1]);
					x++;
					break;
				}
			}
			else if (visitedCells.length > 0) {
				// if there are no neighbouring unvisited cells, go back to the previous cell
				var cell = visitedCells.pop();
				x = cell.x;
				y = cell.y;
			}
			else {
				break;
			}
		}
		
		return {grid: grid, locationHistory: locHistory};
	}
	
	// Destroy wall (NSWE)
	function destroyWall(grid, x, y, wall) {
		
		if (x < GRID_WIDTH-1 && wall == "E") {
			grid[y][x].walls = grid[y][x].walls & 14;
			grid[y][x+1].walls = grid[y][x+1].walls & 13;
		}
		
		if (x > 0 && wall == "W") {
			grid[y][x].walls = grid[y][x].walls & 13;
			grid[y][x-1].walls = grid[y][x-1].walls & 14;
		}
		
		if (y < GRID_WIDTH-1 && wall == "S") {
			grid[y][x].walls = grid[y][x].walls & 11;
			grid[y+1][x].walls = grid[y+1][x].walls & 7;
		}
		
		if (y > 0 && wall == "N") {
			grid[y][x].walls = grid[y][x].walls & 7;
			grid[y-1][x].walls = grid[y-1][x].walls & 11;
		}
	}
	
	// create a cell in memory
	function createCell(x, y, walls) {
		var cell = {};
		cell.x = x;
		cell.y = y;
		cell.visited = false;
		cell.walls = walls;
		
		// borders
		if (cell.x == 0) {
			cell.walls = cell.walls | 2;
		}
		
		if (cell.x == GRID_WIDTH-1) {
			cell.walls = cell.walls | 1;
		}
		
		if (cell.y == 0) {
			cell.walls = cell.walls | 8;
		}
		
		if (cell.y == GRID_WIDTH-1) {
			cell.walls = cell.walls | 4;
		}
		
		// openings
		if (cell.x == 0 && cell.y == 0) {
			cell.walls = cell.walls  & 13;
		}
		
		if (cell.x == GRID_WIDTH-1 && cell.y == GRID_WIDTH-1) {
			cell.walls = cell.walls  & 14;
		}
		return cell;
	}
	
	// Draw Grid
	function drawGrid(grid) {
		for (var j = 0; j < GRID_WIDTH; j++) {
			for (var i = 0; i < GRID_WIDTH; i++) {
				drawWalls(grid[j][i].walls, i*CELL_SIZE, j*CELL_SIZE);
			}
		}
	}
	
	// Draw grid gradually
	function drawAnimateGrid(grid, animTime, locHistory) {
		for (var i = 0; i < locHistory.length; i++) {
			if (ANIM_SPEED*i < animTime) {
				drawWalls(grid[locHistory[i].y][locHistory[i].x].walls, locHistory[i].x*CELL_SIZE, locHistory[i].y*CELL_SIZE);
				//gl.beginPath();
				//gl.arc(locHistory[i].x*CELL_SIZE+5, locHistory[i].y*CELL_SIZE+5, 5, 0, 2 * Math.PI, true);
				//gl.fill();
			}
		}
	}

	// Draw a cell's walls
	// walls param is 4 flags (NSWE). if walls = 1111 then draw all of them.
	function drawWalls(walls, x, y) {
		
		var array;
		
		// North
		if (walls & 8) {
			gl.beginPath();
			gl.moveTo(x, y);
			gl.lineTo(x+CELL_SIZE, y);
			gl.stroke();
		}
	
		// South
		if (walls & 4) {
			gl.beginPath();
			gl.moveTo(x, y+CELL_SIZE);
			gl.lineTo(x+CELL_SIZE, y+CELL_SIZE);
			gl.stroke();
		}

		// West
		if (walls & 2) {
			gl.beginPath();
			gl.moveTo(x, y);
			gl.lineTo(x, y+CELL_SIZE);
			gl.stroke();
		}
	
		// East
		if (walls & 1) {
			gl.beginPath();
			gl.moveTo(x+CELL_SIZE, y);
			gl.lineTo(x+CELL_SIZE, y+CELL_SIZE);
			gl.stroke();
		}
	}
	
	var time, startTime, maze, locationHistory;

	// Animate
	function animate() {

		requestAnimFrame( animate );
				
		time = Date.now();
		
		if (startTime === undefined)
			startTime = time;
 
		var animTime = (time - startTime);
		
		drawAnimateGrid(maze, animTime, locationHistory);
	}
	
	// webGLStart
    function webGLStart() {
        var canvas = document.getElementById("amaze-canvas");
        initGL(canvas);
		
		var grid = createGrid();
       	//drawGrid(grid);
				
		var result = generateMaze(grid);
		maze = result.grid;
		locationHistory = result.locationHistory;
		animate();
    }

</script>


</head>


<body onload="webGLStart();" style="background: black">
	<div style="color: white">
	Randomly generated "perfect" maze using the recursive backtracking algorithm.<br />
	Refresh to generate another.
	</div>
	<br /><br />
	<div style="text-align: center">
    <canvas id="amaze-canvas" style="border: none;" width="680" height="680"></canvas>
	</div>
</body>

</html>
